---
layout: post
title:  "DESåŠ å¯†ç®—æ³•å®ç°"
categories: C++
tags: Algorithm
---

* content
{:toc}

DESç®—æ³•ä¸ºå¯†ç ä½“åˆ¶ä¸­çš„å¯¹ç§°å¯†ç ä½“åˆ¶ï¼Œç”±ç¾å›½IBMå…¬å¸ç ”åˆ¶çš„å¯¹ç§°å¯†ç ä½“åˆ¶åŠ å¯†ç®—æ³•ã€‚ æ˜æ–‡æŒ‰64ä½è¿›è¡Œåˆ†ç»„ï¼Œå¯†é’¥é•¿64ä½ï¼Œå¯†é’¥äº‹å®ä¸Šæ˜¯56ä½å‚ä¸DESè¿ç®—ï¼ˆç¬¬8ã€16ã€24ã€32ã€40ã€48ã€56ã€64ä½æ˜¯æ ¡éªŒä½ï¼Œ ä½¿å¾—æ¯ä¸ªå¯†é’¥éƒ½æœ‰å¥‡æ•°ä¸ª1ï¼‰åˆ†ç»„åçš„æ˜æ–‡ç»„å’Œ56ä½çš„å¯†é’¥æŒ‰ä½æ›¿ä»£æˆ–äº¤æ¢çš„æ–¹æ³•å½¢æˆå¯†æ–‡ç»„çš„åŠ å¯†æ–¹æ³•ã€‚





### ä¸€ã€ç®—æ³•å®ç°

#### å¯†é’¥çš„å¤„ç†

* K1:æŠŠ64ä½å¯†é’¥å»é™¤ç¬¦å·ä½ï¼Œç”¨KT1è¡¨ç½®æ¢ä¸º56ä½å¯†ç 

```c
const static int
KT1[56] = {
	57, 49, 41, 33, 25, 17, 9, 1,
	58, 50, 42, 34, 26, 18, 10, 2,
	59, 51, 43, 35, 27, 19, 11, 3,
	60, 52, 44, 36, 63, 55, 47, 39,
	31, 23, 15, 7, 62, 54, 46, 38,
	30, 22, 14, 6, 61, 53, 45, 37,
	29, 21, 13, 5, 28, 20, 12, 4 },
```

* K2:å°†K1ç”Ÿæˆçš„56ä½å¯†ç åˆ†æˆå·¦åä¸¤ä»½ï¼Œæ¯ä»½28bits,åˆ†åˆ«æ˜¯KL,KR,
* K3:åˆ†åˆ«å°†KL,KRå¾ªç¯å·¦ç§»ï¼Œæ¯æ¬¡å·¦ç§»é‡ä¸ºKEYMOVEè¡¨å¯¹åº”æ•°å­—

```c
KEYMOVE[16] = {
	1, 1, 2, 2, 2, 2, 2, 2,
	1, 2, 2, 2, 2, 2, 2, 1 },
```

* K4:å°†å¾ªç¯å·¦ç§»åKRå’ŒKLï¼Œå†æŠŠKRå’ŒKLåˆå¹¶èµ·æ¥è¿›è¡ŒKT2è¡¨çš„å‹ç¼©ç½®æ¢ï¼Œè¿™é‡Œæ³¨æ„KT2è¡¨ä¸­28è¦é€‰å–ç¬¬55ä½ï¼Œè€Œä¸æ˜¯ï¼ˆ28-1=ï¼‰27ä½ï¼Œæœ€ç»ˆæœ€ç»ˆKey,é‡å¤K2-K4å…±16æ¬¡

```c
KT2[48] = {
	14, 17, 11, 24, 1, 5, 3, 28,
	15, 6, 21, 10, 23, 19, 12, 4,
	26, 8, 16, 7, 27, 20, 13, 2,
	41, 52, 31, 37, 47, 55, 30, 40,
	51, 45, 33, 48, 44, 49, 39, 56,
	34, 53, 46, 42, 50, 36, 29, 32 },
```

#### å¯†æ–‡çš„ç”Ÿæˆ

* C1:å°†è¦åŠ å¯†çš„8å­—èŠ‚æ˜æ–‡ç”¨CT1è¡¨ç½®æ¢ä½ç½®ï¼Œå¹¶åˆ†å¼€å‰32bitsä¸ºCL,å32bitsä¸ºCR

```c
CT1[64] = {
	58, 50, 42, 34, 26, 18, 10, 2,
	60, 52, 44, 36, 28, 20, 12, 4,
	62, 54, 46, 38, 30, 22, 14, 6,
	64, 56, 48, 40, 32, 24, 16, 8,
	57, 49, 41, 33, 25, 17, 9, 1,
	59, 51, 43, 35, 27, 19, 11, 3,
	61, 53, 45, 37, 29, 21, 13, 5,
	63, 55, 47, 39, 31, 23, 15, 7 },
```

* C2:å°†CRç”¨CRCHGè¡¨æ‰©å±•å¹¶ç½®æ¢ä¸º48bitsï¼Œåå’ŒK4å¾—åˆ°çš„keyè¿›è¡Œæ¨¡2åŠ ï¼ˆå¼‚æˆ–ï¼‰ç”Ÿæˆ48bitsåºåˆ—

```c
CRCHG[48] = {
	32, 1, 2, 3, 4, 5, 4, 5,
	6, 7, 8, 9, 8, 9, 10, 11,
	12, 13, 12, 13, 14, 15, 16, 17,
	16, 17, 18, 19, 20, 21, 20, 21,
	22, 23, 24, 25, 24, 25, 26, 27,
	28, 29, 28, 29, 30, 31, 32, 1 },
```

* C3:ç»CRCHGè¡¨æ‰©å±•ç½®æ¢åçš„48bitsåˆ†æˆ8ç»„ï¼Œç”¨äºé€‰æ‹©ç¬¬Sç›’ï¼Œæ¯ç»„6bits,ç¬¬ä¸€å’Œæœ€åä¸€bitç»„æˆä¸€ä¸ªæ•°å­—ï¼Œç”¨äºé€‰æ‹©æŸä¸ªS_boxä¸­æŸè¡Œï¼Œå‰©ä¸‹4bitsç»„æˆä¸€ä¸ªæ•°å­—ï¼Œé€‰æ‹©è¯¥è¡ŒæŸåˆ—çš„æ•°å­—ï¼Œ
* C4:ç»“æœæ˜¯å–å¾—S_boxä¸­ä¸€ä¸ªæ•´æ•°ï¼Œè¯¥æ•´æ•°åªæœ‰ä½4bitså¯èƒ½ç½®ä½ï¼Œä¹Ÿå°±æ˜¯è¯¥æ•°å­—æœ€å¤§ä¸º15ï¼Œ
* C5:ç„¶åç»„æˆ(8 * 4bits = )32bitsåˆæ­¥å¯†æ–‡ï¼Œåé¢è¦ç»è¿‡SCHGè¡¨è¿›è¡Œç½®æ¢ï¼Œ
* C6:å°†ç½®æ¢åçš„ç»“æœå’ŒCLè¿›è¡Œæ¨¡2åŠ ï¼ˆå¼‚æˆ–ï¼‰ï¼Œå­˜åˆ°CLï¼Œäº¤æ¢CLå’ŒCRï¼Œé‡å¤C2-C6å…±16æ¬¡

```c
S_box[8][4][16] = {
	//S1
	{ { 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7 },
	{ 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8 },
	{ 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0 },
	{ 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 } },
	//S2
	{ { 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10 },
	{ 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5 },
	{ 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15 },
	{ 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 } },
	//S3
	{ { 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8 },
	{ 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1 },
	{ 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7 },
	{ 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 } },
	//S4
	{ { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15 },
	{ 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9 },
	{ 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4 },
	{ 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 } },
	//S5
	{ { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9 },
	{ 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6 },
	{ 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14 },
	{ 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 } },
	//S6
	{ { 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11 },
	{ 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8 },
	{ 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6 },
	{ 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 } },
	//S7
	{ { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1 },
	{ 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6 },
	{ 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2 },
	{ 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 } },
	//S8
	{ { 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7 },
	{ 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2 },
	{ 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8 },
	{ 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 } } },
//S_boxå¤„ç†åç½®æ¢ç”¨SCHGè¡¨
SCHG[32] = {
	16, 7, 20, 21, 29, 12, 28, 17,
	1, 15, 23, 26, 5, 18, 31, 10,
	2, 8, 24, 14, 32, 27, 3, 9,
	19, 13, 30, 6, 22, 11, 4, 25 },
```

* C7:æœ€åï¼Œå°†å¤„ç†åçš„8å­—èŠ‚å¯†æ–‡ï¼ˆCL+CRï¼‰ç”¨CT2è¡¨è¿›è¡Œç½®æ¢

```c
CT2[64] = {
	40, 8, 48, 16, 56, 24, 64, 32,
	39, 7, 47, 15, 55, 23, 63, 31,
	38, 6, 46, 14, 54, 22, 62, 30,
	37, 5, 45, 13, 53, 21, 61, 29,
	36, 4, 44, 12, 52, 20, 60, 28,
	35, 3, 43, 11, 51, 19, 59, 27,
	34, 2, 42, 10, 50, 18, 58, 26,
	33, 1, 41, 9, 49, 17, 57, 25 };
```

### äºŒã€ä»£ç å®ç°

#### ç›¸å…³å‡½æ•°ç®€ä»‹

##### ç”¨æˆ·æ¥å£

```c
enum Cipher
{
	DECRYPT = 0,
	ENCRYPT = 1
};
//æ˜æ–‡å…¥å‚in(8bits),é’¥åŒ™å…¥å‚key(8bits)ï¼Œå¯†æ–‡ç¼“å­˜å…¥å‚out(8bits),åŠŸèƒ½é€‰æ‹©å…¥å‚flag
void des_encrypt(const char* in, const char* key, char* out, Cipher flag);
```

##### åŠŸèƒ½å‡½æ•°ï¼ˆç³»ç»Ÿå†…éƒ¨è°ƒç”¨ï¼‰

```c
bool DES_KEY[16][48];
/*å¯†é’¥å¤„ç†ï¼Œç»å¤„ç†çš„å¯†é’¥å­˜äºDES_KEYä¸­*/
void generate_key(const char* in);

/*ç½®æ¢å‡½æ•°ï¼Œå…¥å‚ï¼šç½®æ¢ç”¨è¡¨ï¼Œ   ç½®æ¢å‰æ•°æ®ç¼“å­˜ï¼Œ ç½®æ¢åæ•°æ®ç¼“å­˜ï¼Œ ç½®æ¢åæ•°æ®ç¼“å­˜å¤§å°*/
void Tramsfer(const int inTable[], const bool in[], bool out[], size_t outlenght);

/*å¾ªç¯å·¦ç§»ï¼Œå…¥å‚ï¼šéœ€è¦å·¦ç§»çš„æ•°æ®ç¼“å­˜ï¼Œç¼“å­˜å¤§å°ï¼Œå·¦ç§»æ­¥æ•°*/
void RotateLeft(bool* in, size_t inlenght, size_t count);

/*æ¯”ç‰¹æ•°ç»„è½¬å˜ä¸ºcharæ•°ç»„ï¼Œå…¥å‚ï¼šéœ€è¦è½¬æ¢çš„bitæ•°ç»„ï¼Œbitæ•°ç»„å¤§å°ï¼Œcharæ•°ç»„*/
void Bit2Byte(const bool* in, size_t inlenght, char* out);

/*charæ•°ç»„è½¬å˜ä¸ºbitæ•°ç»„ï¼Œå…¥å‚ï¼šéœ€è¦è½¬æ¢çš„charæ•°ç»„ï¼Œbitæ•°ç»„ï¼Œbitæ•°ç»„å¤§å°*/
void Byte2Bit(const char* in, bool* out, size_t outlenght);

/*æ¨¡2åŠ ï¼Œå¼‚æˆ–ï¼Œç»“æœå­˜äºinoutAä¸­*/
void Xor(bool* inoutA, const bool* inB, size_t lenght);

/*S_boxè¿ç®—ï¼Œå…¥å‚ï¼šå·¦é˜Ÿåˆ—ï¼Œ     å³é˜Ÿåˆ—ï¼Œ                ç”Ÿæˆçš„å¯†é’¥ï¼Œ              è¿ç®—æ¬¡æ•°ï¼Œ  åŠŸèƒ½å‚æ•°*/
void SFunc(bool* CL/*32bits*/, bool* CR/*32bits*/, const DES_KEY key/*16*48bits*/, int count, Cipher flag);
```

#### ç›¸å…³å‡½æ•°å®ç°

##### ç”¨æˆ·æ¥å£

```c
/*åŠ å¯†è§£å¯†*/
	void des_encrypt(const char* in, const char* key, char* out, Cipher flag)
	{
		generate_key(key);
		bool afterFchg[64];
		bool tmp[64];
		Byte2Bit(in, tmp, 64);
		/*
		C1:å°†è¦åŠ å¯†çš„8å­—èŠ‚æ˜æ–‡ç”¨CT1è¡¨ç½®æ¢ä½ç½®ï¼Œ
		å¹¶åˆ†å¼€å‰32bitsä¸ºCL,å32bitsä¸ºCR  
		*/
		Tramsfer(CT1, tmp, afterFchg, 64);
		bool CL[32], CR[32];
		for (int i = 0; i < 32; i++)
		{
			CL[i] = afterFchg[i];
			CR[i] = afterFchg[i + 32];
		}
		//è¿›è¡ŒSç›’è¿ç®—
		SFunc(CL, CR,  16, flag);
		/*C7:æœ€åï¼Œå°†å¤„ç†åçš„8å­—èŠ‚å¯†æ–‡ï¼ˆCL+CRï¼‰ç”¨CT2è¡¨è¿›è¡Œç½®æ¢*/
		memset(afterFchg, 0, 64);
		for (int i = 0; i < 32; i++)
		{
			afterFchg[i] = CL[i];
			afterFchg[i + 32] = CR[i];
		}
		bool afterLchg[64];

		Tramsfer(CT2, afterFchg, afterLchg, 64);
		Bit2Byte(afterLchg, 64, out);
	}
```

##### åŠŸèƒ½å‡½æ•°ï¼ˆç³»ç»Ÿå†…éƒ¨è°ƒç”¨ï¼‰

* ç½®æ¢å‡½æ•°Tramsfer

```c
	void Tramsfer(const int inTable[],const bool* in, bool* out, size_t outlenght)
	{
		memset(out, 0, outlenght);
		for (size_t i = 0; i < outlenght; i++)
		{
			out[i] = in[inTable[i] - 1];
		}
	}
```

* å¾ªç¯å·¦ç§»RotateLeft

```c
	void RotateLeft(bool* in,size_t inlenght,size_t count)
	{
		bool tmp[30];
		memset(tmp, 0, 30);
		memcpy(tmp,in,count);
		memcpy(in, in + count, inlenght - count);
		memcpy(in+inlenght-count, tmp, count);
	}
```

* æ¯”ç‰¹æ•°ç»„è½¬å˜ä¸ºcharæ•°ç»„Bit2Byte

```c
	void Bit2Byte(const bool* in, size_t inlenght, char* out)
	{
		memset(out, 0, (inlenght + 7) / 8);
		for (size_t i = 0; i < inlenght; i++)
			out[i / 8] |= in[i] << (7-(i % 8));
	}
```

* charæ•°ç»„è½¬å˜ä¸ºbitæ•°ç»„Byte2Bit

```c
	void Byte2Bit(const char* in, bool* out, size_t outlenght)
	{
		memset(out, 0, outlenght);
		for (size_t i = 0; i < outlenght; i++)
			out[i] = (in[i / 8] >> (7-(i % 8))) & 1;
	}
```

* æ¨¡2åŠ ï¼Œå¼‚æˆ–

```c
	void Xor(bool* inoutA , const bool* inB , size_t lenght)
	{
		for (size_t i = 0; i < lenght; i++)
		{
			inoutA[i] ^= inB[i];
		}
	}
```

* S_boxè¿ç®—ï¼Œæ ¸å¿ƒ

```c
	void SFunc(bool* CL/*32bits*/, bool* CR/*32bits*/,
		 int count, Cipher flag)
	{
		/*
		C2:å°†CRç”¨CRCHGè¡¨æ‰©å±•å¹¶ç½®æ¢ä¸º48bitsï¼Œ
		åå’ŒK4å¾—åˆ°çš„keyè¿›è¡Œæ¨¡2åŠ ï¼ˆå¼‚æˆ–ï¼‰ç”Ÿæˆ48bitsåºåˆ— 
		*/
		bool tmp[48];		
		Tramsfer(CRCHG, CR, tmp, 48);		
		if (flag)
			Xor(tmp, DES_KEY[16 - count], 48);
		else
			Xor(tmp, DES_KEY[count - 1], 48);
		/*
		C3:ç»CRCHGè¡¨æ‰©å±•ç½®æ¢åçš„48bitsåˆ†æˆ8ç»„ï¼Œç”¨äºé€‰æ‹©ç¬¬Sç›’ï¼Œ
		æ¯ç»„6bits,ç¬¬ä¸€å’Œæœ€åä¸€bitç»„æˆä¸€ä¸ªæ•°å­—ï¼Œç”¨äºé€‰æ‹©æŸä¸ªSç›’ä¸­æŸè¡Œï¼Œ
		å‰©ä¸‹4bitsç»„æˆä¸€ä¸ªæ•°å­—ï¼Œé€‰æ‹©è¯¥è¡ŒæŸåˆ—çš„æ•°å­—
		*/		
		int S = 0,a = 0,b = 0;
		int result;
		bool afterS[32];
		memset(afterS, 0, 32);
		for (int i = 0; i < 8;i++)
		{
			S = 6 * i;
			a = (tmp[S] << 1) + tmp[S + 5];
			b = (tmp[S + 1] << 3) + (tmp[S + 2] << 2) + (tmp[S + 3] << 1) + tmp[S + 4];
			/*C4:ç»“æœæ˜¯å–å¾—Sç›’ä¸­ä¸€ä¸ªæ•´æ•°ï¼Œ
			è¯¥æ•´æ•°åªæœ‰ä½4bitså¯èƒ½ç½®ä½ï¼Œ
			ä¹Ÿå°±æ˜¯è¯¥æ•°å­—æœ€å¤§ä¸º15*/
			result = S_box[i][a][b];
			//å°†æ‰€æœ‰çš„ç»“æœä¿å­˜åœ¨afterSä¸­
			for (int j = 0; j < 4;j++)
				afterS[i * 4 + j] |= (result >> (3 - j)) & 1;
		}
		/*
		C5:ç„¶åç»„æˆ(8 * 4bits = )32bitsåˆæ­¥å¯†æ–‡ï¼Œ
		åé¢è¦ç»è¿‡SCHGè¡¨è¿›è¡Œç½®æ¢
		*/
		bool afterTram[32];
		Tramsfer(SCHG, afterS, afterTram, 32);
		/*C6:å°†ç½®æ¢åçš„ç»“æœå’ŒCLè¿›è¡Œæ¨¡2åŠ ï¼ˆå¼‚æˆ–ï¼‰ï¼Œ
		å­˜åˆ°CLï¼Œäº¤æ¢CLå’ŒCRï¼Œé‡å¤C2-C6å…±16æ¬¡*/
		Xor(CL, afterTram, 32);
		if (count == 1)
		{
			/*è¿›è¡Œåˆ°ç¬¬16æ¬¡æ—¶è¦æŠŠCR,CLäº¤æ¢*/
			bool temp[32];
			memset(temp, 0, 32);
			memcpy(temp, CL, 32);
			memcpy(CL, CR, 32);
			memcpy(CR, temp, 32);
			return;
		}
		//äº¤æ¢CRå’ŒCLå¹¶è¿›è¡Œé€’å½’ï¼Œå…±æ‰§è¡Œ16æ¬¡S_BOXè¿ç®—
		SFunc(CR, CL,  count - 1,flag); 
	}
```	

* ç”Ÿæˆé’¥åŒ™

```c
	void generate_key(const char* in)
	{
		/*
		K1:æŠŠ64ä½å¯†é’¥å»é™¤ç¬¦å·ä½ï¼Œç”¨KT1è¡¨ç½®æ¢ä¸º56ä½å¯†ç 
		*/
		bool tmp[64];
		Byte2Bit(in, tmp, 64);
		bool afterFchg[56];
		Tramsfer(KT1, tmp, afterFchg, 56);
		/*K2:å°†K1ç”Ÿæˆçš„56ä½å¯†ç åˆ†æˆå·¦åä¸¤ä»½ï¼Œæ¯ä»½28bits,åˆ†åˆ«æ˜¯KL,KR*/
		bool* KL = afterFchg, *KR = &afterFchg[28];
		/*
		K4:å°†å¾ªç¯å·¦ç§»åKRå’ŒKLï¼Œ
		å†æŠŠKRå’ŒKLåˆå¹¶èµ·æ¥è¿›è¡ŒKT2è¡¨çš„å‹ç¼©ç½®æ¢ï¼Œ
		è¿™é‡Œæ³¨æ„KT2è¡¨ä¸­28è¦é€‰å–ç¬¬55ä½ï¼Œè€Œä¸æ˜¯ï¼ˆ28-1=ï¼‰27ä½ï¼Œ
		æœ€ç»ˆæœ€ç»ˆKey,
		é‡å¤K2-K4å…±16æ¬¡
		*/
		for (int i = 0; i < 16; i++)
		{
			/*K3:åˆ†åˆ«å°†KL,KRå¾ªç¯å·¦ç§»ï¼Œæ¯æ¬¡å·¦ç§»é‡ä¸ºKEYMOVEè¡¨å¯¹åº”æ•°å­— */
			RotateLeft(KL, 28, KEYMOVE[i]);
			RotateLeft(KR, 28, KEYMOVE[i]);
			memset(DES_KEY[i], 0, 48);
			for (size_t j = 0; j < 48; j++)
			{
				if (KT2[j] == 28)
					DES_KEY[i][j] = afterFchg[55];
				else
					DES_KEY[i][j] = afterFchg[KT2[i] - 1];
			}
		}
	}
```

### æœ€å

ç¼–å†™æ—¶åº”è¯¥æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š
* ç»å¸¸ç”¨memsetåˆå§‹åŒ–æ•°ç»„ï¼ŒåŸå› æœ‰ä¸¤ä¸ªï¼š
ï¼ˆ1ï¼‰æœ¬ç®—æ³•è¿ç”¨çš„æ˜¯boolæ•°ç»„æ¨¡æ‹Ÿbitæ•°ç»„ï¼Œboolå 8bitsï¼Œè€Œæˆ‘ä»¬åªå¸Œæœ›ç”¨åˆ°å…¶ä¸­çš„ç¬¬ä¸€ä¸ªbitï¼Œé™¤äº†boolä¸ºfalseæ—¶æ˜¯ç¡®å®šæ¯bitä¸º0å¤–ï¼Œå½“boolä¸ºtrueæ—¶æ¯bitæ˜¯ä»€ä¹ˆå°±éš¾ä»¥ç¡®å®šäº†ï¼Œè€Œä¸”ç®—æ³•ä¸­ä¼šå¯¹boolæ•°ç»„è¿›è¡Œæ¨¡2åŠ ï¼Œä¼šä½¿å¢åŠ ç»“æœçš„ä¸ç¡®å®šæ€§ï¼›
ï¼ˆ2ï¼‰å¦‚æœåŸå§‹keyç”¨çš„æ˜¯ä¸è¶³8å­—èŠ‚çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿè¦å¯¹åŸå§‹keyè¿›è¡Œåˆå§‹åŒ–ï¼Œå› ä¸ºç”Ÿæˆkeyä¼šç”¨åˆ°åŸå§‹keyçš„8å­—èŠ‚ï¼Œä½ é™¤äº†èƒ½ç¡®å®šè‡ªå·±è¾“å…¥çš„é‚£å‡ ä¸ªå­—èŠ‚å¤–ï¼Œå‰©ä¸‹çš„å­—èŠ‚æ˜¯ä¸ç¡®å®šçš„ã€‚

* K4æ­¥éª¤:å°†å¾ªç¯å·¦ç§»åKRå’ŒKLï¼Œå†æŠŠKRå’ŒKLåˆå¹¶èµ·æ¥è¿›è¡ŒKT2è¡¨çš„å‹ç¼©ç½®æ¢ï¼Œè¿™é‡Œæ³¨æ„KT2è¡¨ä¸­28è¦é€‰å–ç¬¬55ä½ï¼Œè€Œä¸æ˜¯ï¼ˆ28-1=ï¼‰27ä½ï¼›

* ä»charæ•°ç»„å’Œbitæ•°ç»„è½¬æ¢æ—¶æ³¨æ„è½¬ç§»é¡ºåº
å¦‚charæ•°ç»„æ˜¯`10000111 00010001`æŒ‰ç…§è½¬æ¢æˆbitæ•°ç»„çš„è¯ï¼š

```c
	for (size_t i = 0; i < outlenght; i++)
		out[i] = (in[i / 8] >> (7-(i % 8))) & 1;
```

å¾—åˆ°bitæ•°ç»„:`10000111 00010001`
è€Œå¦‚æœæŒ‰ç…§ï¼š

```c
	for (size_t i = 0; i < outlenght; i++)
		out[i] = (in[i / 8] >> (i % 8)) & 1;
```

ä¼šå¾—åˆ°bitæ•°ç»„ä¸º`11100001 10001000`

* æµ‹è¯•ä»£ç 

```c
int main()
{	
	string key  = "cheng";					//é’¥åŒ™
	string text = "Welcome to cheng's blog! www.cheng668.com";    //æ˜æ–‡
	string ent  = "";							//å¯†æ–‡
	string destring = "";						//è§£å¯†æ˜æ–‡

	//ä¿®æ”¹å¯†é’¥æ ¼å¼
	char key11[10];
	memset(key11, 0, 10);
	if (key.size() < 8)
		memcpy(key11, key.c_str(), sizeof(key.c_str()));
	else
		memcpy(key11, key.c_str(), 8);

	//å°†æ˜æ–‡åˆ†å¼€æ¯8ä¸ªå­—èŠ‚è¿›è¡ŒåŠ å¯†
	for (size_t i = 0;i<(text.length()+7)/8;i++)
	{
	    char entext[9],intext[9];
		memset(entext, 0, 9);
		memset(intext, 0, 9);
		_memccpy(intext, text.c_str() + 8 * i, NULL, 8);
		des_encrypt(intext, key11, entext, ENCRYPT);
		ent += entext;
	}
	cout << ent << endl;

	//å°†å¯†æ–‡è½¬å˜ä¸ºæ¯8ä¸ªå­—èŠ‚è¿›è¡Œè§£å¯†
	for (size_t i = 0; i < (ent.length() + 7) / 8; i++)
	{
		char outtext[9],detext[9];
		memset(outtext, 0, 9);
		memset(detext, 0, 9);
		_memccpy(detext, ent.c_str() + 8 * i, NULL, 8);
		des_encrypt(detext, key11, outtext, DECRYPT);
		destring += outtext;
	}
	cout << destring << endl;
	system("pause");
	return 0;
}
```

### githubä»£ç ï¼š

**[DESç®—æ³•ä»£ç  ğŸ‡¨ğŸ‡³](https://github.com/cheng668/Algorithm-DES)**