---
layout: post
title:  "C++ Pattern-Facade"
categories: C++
tags: Pattern
---

* content
{:toc}

在博主看来，适配器模式就像是外观模式的特例，适配器模式适配的是一个类的接口，而外观模式是用于适配一个子系统(包括很多类)的很多接口并把这些接口进行组合运用。






外观模式类图如下，《设计模式》中的例子是用外观模式为编译子系统的提供一个易用接口，其中编译子系统用到很多其他设计模式，这里为了着重理解外观模式，简化了以下子系统：

![image](https://raw.githubusercontent.com/cheng668/image/master/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.png)

### 一.意图：

* 为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

### 二.适用性：

* 为复杂子系统提供简单接口，但仍然可直接调用子系统进行定制。
* 将子系统与客户及其他子系统分离，提高子系统独立性和可移植性。
* 用于构建层次结构，简化各层次子系统依赖关系。

### 三.参与者：

#### Facade( Complier)
* 知道哪些子系统类负责处理请求。
* 将客户的请求代理给适当的子系统对象。

#### Subsystem classes( Scanner, Parser)
* 实现子系统的功能。
* 处理由 Facade对象指派的任务。
* 没有指向 Facade的指针。

### 四.协作：

* 客户程序通过发送请求给 Facade的方式与子系统通讯。
* 使用 Facade的客户程序不需要直接访问子系统对象。

### 五.效果：

* 屏蔽子系统组件，使其方便使用。
* 使客户程序和子系统解耦。
* 不限制客户直接使用子系统。

### 六.实现：

* 降低客户-子系统耦合度，可使用继承实现抽象类 Facade的方式调用不同的子系统，也可以用不同子系统直接配置 Facade子对象。
* 公共子系统类和私有子系统类。增加命名空间仅暴露公共子系统类。

### 七.应用：

* 编译系统，虚拟存储框架

### 八.相关模式：

* Astract Factory模式：可以与 Facade模式一起以提供一个接口，用于以一种子系统独立的方式创建子系统对象。也可代替 Facade模式隐藏与平台相关的类。
* Mediator模式：相似之处是都抽象了一些已有类的功能。但 Mediator模式是对同事间的通讯进行抽象，通常集中不属于任意单个对象的功能，而 Facade仅对子系统对象进行抽象，并不会定义新功能，子系统也不知道 Facade的存在。
* Facade一般是只需要一个，用 Singleton模式。

### 九.代码：

**[外观模式源码例子 🇨🇳](https://github.com/cheng668/Pattern-Facade)**